# データ処理仕様書

**作成日**: 2025-11-18 15:30
**最終更新**: 2025-11-19
**対象**: RS2024サンキー図システム - データ処理パイプライン

## 概要

本システムのデータ処理パイプラインは、RSシステムの生CSVデータから5列サンキー図用プリセットJSONファイルまでの一連の処理を定義する。

---

## 1. データ処理フロー

```
[RSシステム]
    ↓ ダウンロード
[Shift_JIS ZIP (15ファイル)]
    ↓ ZIP解凍
[Shift_JIS CSV (15ファイル)]
    ↓ 正規化処理 (Python + neologdn)
[UTF-8 正規化CSV]
    ↓ パース・集計
[構造化JSON (rs2024-structured.json, 約110MB)]
    ↓ Top3再帰選択
[プリセットJSON (rs2024-preset-top3.json, 約29KB)]
    ↓ 配信
[Next.js Public Assets]
```

---

## 2. ステージ1: CSVダウンロード・正規化

### 2.1 スクリプト

- **ファイル**: `scripts/normalize_csv.py`
- **実行コマンド**: `npm run normalize`
- **前提条件**: Python 3.x, neologdn

### 2.2 処理内容

#### Phase 1: ZIPファイルの配置

- **データソース**: https://rssystem.go.jp/download-csv/2024 から手動ダウンロード
- **配置先**: `data/download/RS_2024/`
- **対象ファイル**: ZIPファイル（CSVが含まれる）

#### Phase 2: ZIP解凍

スクリプトが自動的に`data/download/RS_2024/`内の全ZIPファイルを解凍:
- **解凍先**: 同じディレクトリ内
- **エンコーディング**: Shift_JIS

**主要CSVファイル**:
```
1-1_2024_基本情報_組織情報.csv
2-1_2024_予算・執行_サマリ.csv
2-2_2024_予算・執行_予算の状況.csv
2-3_2024_予算・執行_執行額の内訳.csv
5-1_2024_支出先_支出情報.csv
```

#### Phase 3: テキスト正規化

各CSVセルに対して以下の処理を順次適用：

1. **neologdn正規化**（最優先）:
   ```python
   import neologdn
   text = neologdn.normalize(text)
   ```

2. **丸数字の変換**: ①②③... → 1,2,3...
   ```python
   circled = '①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳'
   for i, char in enumerate(circled, 1):
       text = text.replace(char, str(i))
   ```

3. **Unicode NFKC正規化**: 全角英数字→半角、異体字統一
   ```python
   text = unicodedata.normalize('NFKC', text)
   ```

4. **和暦→西暦変換**:
   ```python
   令和5年 → 2023年
   平成30年 → 2018年
   昭和64年 → 1989年
   ```

5. **全角括弧→半角括弧変換**:
   ```python
   （） → ()
   ```

6. **ハイフン・ダッシュの統一**:
   ```python
   −, －, ‐, –, —, ― → - (ASCIIハイフン)
   ```

7. **カタカナ長音記号の誤用修正**:
   ```python
   連続長音を1つに: コーーヒー → コーヒー
   ```

8. **連続空白の削除**:
   ```python
   re.sub(r'\s+', ' ', text).strip()
   ```

#### Phase 4: 出力とクリーンアップ

- **エンコーディング**: UTF-8 (BOMなし)
- **出力先**: `data/year_2024/`
- **クリーンアップ**: `data/download/RS_2024/` 内のZIP以外のファイルを削除

### 2.3 正規化の意義

| 課題 | 正規化による解決 |
|------|----------------|
| 文字コード混在 | UTF-8統一でプラットフォーム依存性排除 |
| 表記ゆれ | NFKC正規化で全角/半角統一 |
| 和暦の扱いづらさ | 西暦変換で年度計算を簡素化 |
| ハイフンの混乱 | ASCII統一でマッチング精度向上 |
| 不要な空白 | データクリーニングで処理効率化 |

---

## 3. ステージ2: CSV読み込みと構造化JSON生成

### 3.1 スクリプト

- **ファイル**: `scripts/generate-structured-json.ts`
- **実行コマンド**: `npm run generate-structured`
- **出力**: `public/data/rs2024-structured.json` (約110MB)

### 3.2 処理内容

#### CSV読み込み (`scripts/csv-reader.ts`)

エンコーディング自動判定:

```typescript
// UTF-8を優先的に試行（正規化後CSV対応）
try {
  content = buffer.toString('utf-8');
  if (content.includes('�')) {
    throw new Error('UTF-8 decoding failed');
  }
} catch {
  // Shift_JISにフォールバック（元のCSV対応）
  content = iconv.decode(buffer, 'Shift_JIS');
}
```

CSVパース仕様:
- **フィールド区切り**: カンマ (`,`)
- **クォート対応**: ダブルクォート (`"`) 囲み
- **エスケープ**: `""` → `"`
- **改行コード**: `\r\n` または `\n`
- **空行処理**: スキップ

#### 構造化JSON生成

3つの主要CSVファイルを統合:

1. **組織情報** (`1-1_2024_基本情報_組織情報.csv`)
2. **予算情報** (`2-2_2024_予算・執行_予算の状況.csv`, `2-3_2024_予算・執行_執行額の内訳.csv`)
3. **支出情報** (`5-1_2024_支出先_支出情報.csv`)

**出力データ構造** (`types/structured.ts`):
```typescript
interface RS2024StructuredData {
  metadata: StructuredMetadata;
  budgetTree: BudgetTree;
  budgets: BudgetRecord[];
  spendings: SpendingRecord[];
}
```

**統計**:
- 府省庁数: 20
- 事業数: 15,111
- 支出先数: 25,892
- 総予算額: 146.63兆円

---

## 4. ステージ3: プリセットTop3サンキー図JSON生成

### 4.1 スクリプト

- **ファイル**: `scripts/generate-preset-json.ts`
- **実行コマンド**: `npm run generate-preset`
- **入力**: `public/data/rs2024-structured.json`
- **出力**: `public/data/rs2024-preset-top3.json` (約29KB)

### 4.2 5列サンキー図構造

```
列0: 予算総計 (budget-total)
  ↓
列1: 府省庁（予算）
  - ministry-budget-{id} (Top3府省庁)
  - ministry-budget-other (その他の府省庁)
  ↓
列2: 事業（予算）
  - project-budget-{id} (各府省庁のTop3事業)
  - project-budget-other-{ministryId} (その他の事業)
  ↓
列3: 事業（支出）
  - project-spending-{id} (列2と同じ事業の支出ビュー)
  ↓
列4: 支出先
  - recipient-{id} (各事業のTop3支出先)
  - recipient-other-named (支出先名が「その他」のもの全体)
  - recipient-other-aggregated (その他の支出先)
```

### 4.3 Top3再帰選択アルゴリズム

#### ステップ1: Top3府省庁を選択

予算額（totalBudget）でソートし、上位3府省庁を選択:

```typescript
const topMinistries = data.budgetTree.ministries
  .sort((a, b) => b.totalBudget - a.totalBudget)
  .slice(0, 3);

// その他の府省庁の予算合計を計算
const otherMinistriesBudget = data.budgetTree.ministries
  .slice(3)
  .reduce((sum, m) => sum + m.totalBudget, 0);
```

#### ステップ2: 各府省庁のTop3事業を選択

各府省庁ごとに、所属する全事業を予算額でソートし上位3件を選択:

```typescript
for (const ministry of topMinistries) {
  const ministryProjects = data.budgets
    .filter(p => p.ministry === ministry.name);

  const top3Projects = ministryProjects
    .sort((a, b) => b.totalBudget - a.totalBudget)
    .slice(0, 3);

  // その他の事業の予算合計を計算
  const otherBudget = ministryProjects
    .slice(3)
    .reduce((sum, p) => sum + p.totalBudget, 0);
}
```

#### ステップ3: 全事業から支出先名「その他」への支出を集計

TopNフィルタリングの前に、全事業から支出先名が「その他」である支出を抽出し、集計:

```typescript
const otherNamedSpendingByProject = new Map<number, number>();

for (const project of data.budgets) {
  const otherNamedSpendings = data.spendings
    .filter(s => project.spendingIds.includes(s.spendingId))
    .filter(s => s.spendingName === 'その他');

  const otherNamedTotal = otherNamedSpendings.reduce((sum, s) => {
    const projectSpending = s.projects.find(p => p.projectId === project.projectId);
    return sum + (projectSpending?.amount || 0);
  }, 0);

  if (otherNamedTotal > 0) {
    otherNamedSpendingByProject.set(project.projectId, otherNamedTotal);
  }
}
```

#### ステップ4: 各Top3事業のTop3支出先を選択（「その他」を除く）

各事業ごとに、「その他」を除外した支出先を支出額でソートし上位3件を選択:

```typescript
for (const project of topProjects) {
  const projectSpendings = data.spendings
    .filter(s => project.spendingIds.includes(s.spendingId))
    .filter(s => s.spendingName !== 'その他')  // 「その他」を除外
    .map(s => {
      const projectSpending = s.projects.find(p => p.projectId === project.projectId);
      return {
        spending: s,
        amountFromThisProject: projectSpending?.amount || 0,
      };
    });

  const top3Spendings = projectSpendings
    .sort((a, b) => b.amountFromThisProject - a.amountFromThisProject)
    .slice(0, 3);

  // その他の支出先の合計（「その他」という名前のものは含まない）
  const otherSpendingTotal = projectSpendings
    .slice(3)
    .reduce((sum, ps) => sum + ps.amountFromThisProject, 0);
}
```

### 4.4 「その他」ノードと「その他の支出先」ノードの分離

#### 設計原則

1. **「その他」ノード (`recipient-other-named`)**
   - 支出先名が「その他」である全事業からの支出を集約
   - 約26兆円
   - 独立した最終ノード

2. **「その他の支出先」ノード (`recipient-other-aggregated`)**
   - TopN以外の支出先への支出
   - その他の事業（予算）からの予算額（「その他」支出を除く）
   - その他の府省庁の予算額（「その他」支出を除く）
   - 約51兆円
   - 独立した最終ノード

3. **両者の関係**
   - 相互にリンクは存在しない
   - それぞれが独立した最終ノード

#### 「その他」ノードへのリンク

```typescript
// Top3事業（支出）→ 「その他」ノード
for (const [projectId, otherNamedAmount] of otherNamedSpendingByProject.entries()) {
  if (topProjectIds.has(projectId)) {
    links.push({
      source: `project-spending-${projectId}`,
      target: 'recipient-other-named',
      value: otherNamedAmount,
    });
  }
}

// その他の事業（予算）→ 「その他」ノード
for (const [ministryId, amount] of otherProjectsOtherNamedByMinistry.entries()) {
  links.push({
    source: `project-budget-other-${ministryId}`,
    target: 'recipient-other-named',
    value: amount,
  });
}

// その他の府省庁 → 「その他」ノード
if (otherMinistriesOtherNamedAmount > 0) {
  links.push({
    source: 'ministry-budget-other',
    target: 'recipient-other-named',
    value: otherMinistriesOtherNamedAmount,
  });
}
```

#### 「その他の支出先」ノードへのリンク

```typescript
// その他の事業（予算）→ その他の支出先（「その他」支出を除く）
for (const ministry of topMinistries) {
  const otherBudget = otherProjectsBudgetByMinistry.get(ministry.name);
  const otherNamedAmount = otherProjectsOtherNamedByMinistry.get(ministry.name);
  const adjustedBudget = otherBudget - otherNamedAmount;

  if (adjustedBudget > 0) {
    links.push({
      source: `project-budget-other-${ministry.id}`,
      target: 'recipient-other-aggregated',
      value: adjustedBudget,
    });
  }
}

// その他の府省庁 → その他の支出先（「その他」支出を除く）
const adjustedOtherMinistriesBudget = otherMinistriesBudget - otherMinistriesOtherNamedAmount;
if (adjustedOtherMinistriesBudget > 0) {
  links.push({
    source: 'ministry-budget-other',
    target: 'recipient-other-aggregated',
    value: adjustedOtherMinistriesBudget,
  });
}

// Top3事業（支出）→ その他の支出先（TopN以外）
for (const [projectId, otherAmount] of otherSpendingsByProject.entries()) {
  if (otherAmount > 0) {
    links.push({
      source: `project-spending-${projectId}`,
      target: 'recipient-other-aggregated',
      value: otherAmount,
    });
  }
}
```

### 4.5 プリセットJSON出力統計

- **ファイルサイズ**: 約29KB
- **ノード数**: 45
- **リンク数**: 61
- **カバー率**: 約50%（73.58兆円 / 146.63兆円）
- **「その他」ノード**: 約26兆円
- **「その他の支出先」ノード**: 約51兆円

---

## 5. データ整合性検証

### 5.1 構造化JSONバリデーション

```typescript
// budgets配列の検証
for (const budget of data.budgets) {
  if (!budget.projectId || !budget.ministry || !budget.projectName) {
    throw new Error(`Invalid budget record: ${JSON.stringify(budget)}`);
  }
  if (budget.totalBudget < 0) {
    throw new Error(`Negative totalBudget: ${budget.projectId}`);
  }
}

// spendings配列の検証
for (const spending of data.spendings) {
  if (!spending.spendingId || !spending.spendingName) {
    throw new Error(`Invalid spending record: ${JSON.stringify(spending)}`);
  }
  for (const project of spending.projects) {
    if (project.amount < 0) {
      throw new Error(`Negative spending amount: ${spending.spendingId}`);
    }
  }
}
```

### 5.2 サンキー図データバリデーション

```typescript
function validateSankeyData(data: SankeyData): void {
  const nodeIds = new Set(data.nodes.map(n => n.id));

  for (const link of data.links) {
    // ノードID存在チェック
    if (!nodeIds.has(link.source)) {
      throw new Error(`Invalid source: ${link.source}`);
    }
    if (!nodeIds.has(link.target)) {
      throw new Error(`Invalid target: ${link.target}`);
    }

    // 値チェック
    if (link.value <= 0) {
      throw new Error(`Invalid value: ${link.value}`);
    }

    // 自己ループチェック
    if (link.source === link.target) {
      throw new Error('Self-loop detected');
    }
  }
}
```

### 5.3 データ品質保証

| 項目 | 検証内容 |
|------|---------|
| ノードID一意性 | 重複チェック |
| リンク参照整合性 | source/targetがnodes配列に存在 |
| 金額正当性 | value > 0 |
| 自己ループ禁止 | source ≠ target |
| 孤立ノード回避 | すべてのノードが少なくとも1本のリンクを持つ |
| 「その他」分離 | 「その他」と「その他の支出先」が独立 |

---

## 6. パフォーマンス最適化

### 6.1 二段階生成戦略

**ステージ1: 構造化JSON**
- 完全なデータを保持（約110MB）
- サーバーサイドで生成（`npm run generate-structured`）
- Git管理対象外（大きすぎるため）

**ステージ2: プリセットJSON**
- Top3選択による軽量版（約29KB）
- サーバーサイドで生成（`npm run generate-preset`）
- Git管理対象（小さいのでコミット可能）

### 6.2 ファイルサイズ比較

| ファイル | サイズ | ノード数 | リンク数 | カバー率 |
|---------|-------|---------|---------|---------|
| rs2024-structured.json | 約110MB | - | - | 100% |
| rs2024-preset-top3.json | 約29KB | 45 | 61 | 50% |

### 6.3 配信戦略

- **配置**: `public/data/` → Next.js静的アセット
- **キャッシュバスティング**: タイムスタンプクエリパラメータ（`?v=${timestamp}`）
- **配信**: Vercel Edge Network経由
- **初期表示**: プリセットJSONのみ読み込み（< 100ms）

---

## 7. エラーハンドリング

### 7.1 CSV読み込みエラー

```typescript
if (!fs.existsSync(csvPath)) {
  console.error('❌ CSVファイルが見つかりません');
  console.error('npm run normalize を実行してください');
  process.exit(1);
}
```

### 7.2 データ不整合エラー

```typescript
if (!budgetMap.has(projectId)) {
  console.warn(`プロジェクトID ${projectId} の予算情報が見つかりません`);
  continue; // スキップ
}
```

### 7.3 正規化エラー

```python
try:
    normalize_csv_file(input_path, output_path)
except Exception as e:
    print(f'❌ エラー: {input_path.name} - {e}')
    # 処理を継続（他のファイルに影響させない）
```

### 7.4 JSON生成エラー

```typescript
// 構造化JSON生成時
if (data.budgets.length === 0) {
  throw new Error('予算データが空です');
}

// プリセットJSON生成時
if (!fs.existsSync('public/data/rs2024-structured.json')) {
  console.error('❌ 構造化JSONが見つかりません');
  console.error('npm run generate-structured を先に実行してください');
  process.exit(1);
}
```

---

## 8. テスト戦略

### 8.1 単体テスト

- CSVパース: 各種エンコーディング、エスケープ、改行コード
- 正規化: neologdn正規化、各変換ルールの個別検証
- 金額パース: カンマ、空白、不正値
- Top3選択: 境界値テスト（0件、1件、3件、4件以上）

### 8.2 統合テスト

1. 正規化 → 構造化JSON → プリセットJSON の一連フロー
2. 生成されたJSONの妥当性検証
3. サンキー図の描画テスト（Nivo互換性）
4. 「その他」ノード分離の検証

### 8.3 手動検証

```bash
# セットアップ実行
npm run normalize
npm run generate-structured
npm run generate-preset

# ファイル確認
ls data/year_2024/*.csv
ls public/data/*.json

# JSON検証
jq '.metadata' public/data/rs2024-structured.json
jq '.metadata' public/data/rs2024-preset-top3.json

# ノード・リンク数確認
jq '.sankey.nodes | length' public/data/rs2024-preset-top3.json
jq '.sankey.links | length' public/data/rs2024-preset-top3.json
```

---

## 変更履歴

| 日付 | 変更内容 | 担当 |
|------|---------|------|
| 2025-11-18 | 初版作成 | Claude |
| 2025-11-19 | 5列サンキー図構造・「その他」分離を反映 | Claude |
